### Идея
Научимся искать следующую лексикографически перестановку. Тогда если мы отсортируем массив $nums$ по возрастанию и будем в цикле искать следующую перестановку, пока массив не окажется отсортированным по убыванию, мы переберем все возможные перестановки $nums$, причем каждую по одному разу.


### Алгоритм
В реализации я использую std::next_permutation. Сейчас я объясню идейно решение, работающее за такую же асимптотику.

Заметим, что наименьшая лексикографически перестановка - упорядоченная по возрастанию; наибольшая - по убыванию. Воспользовавшись аналогичным замечанием для произвольного суффикса массива, получим следующее утверждение:

Пусть массив $T = P + S$, причем $S$ - суффикс такой что
1) он не упорядочен по убыванию
2) $S[1: ]$ упорядочен по убыванию

Пусть $S0$ = $S$[0]; $S1$ - наименьший элемент $S$[1:], больший $S0$ (такой очевидно будет в силу условий накладываемых на S). Тогда следующая перестановка будет иметь вид $K = P + [S1, ] + sort(S$ без $S1)$  (угу, выражение написано на неком python++)

*Доказательство:* 
1) Заметим, что все изменения в суффиксе $S$[1:] будут давать меньшую лексикографически перестановку. Это следует из того, что упорядоченная по убыванию перестановка - наибольшая лексикографически
2) Перестановка K действительно больше перестановки $T$ - у них общий префикс $P$, при этом следующий за префиксом символ у $K$ больше
3) Не существует перестановок больших $T$, но меньших $K$. Предположим противное - найдется перестановка $L$: $T < L < K$. Тогда она обязана начинаться с того же префикса $P$. Поскольку в $S$ нет элементов между $S0$ и $S1$, то $L[|P|]$ равен либо $S0$, либо $S1$. Если $L[|P|]$ равен $S0$, то получено противоречие в силу пункта (1) доказательства. Значит $L[|P|]$ равен $S1$. Поскольку $L[|P|+1:]$ состоит из тех же символов, что и $K[|P| + 1:]$, а $K[|P| + 1:]$ отсортирован по возрастанию, то мы снова получаем противоречие.

Значит, $K$ действительно является следующей перестановкой после $T$. Ее можно вычислить за линию:
1) Разбиение $T$ в виде $T = P + S$ из утверждения получается за линию очевидным образом
2) S1 можно найти проходом за линию - на асимптотику это не повлияет
3) Осталось развернуть S за линию и поменять S1 и S0 местами. Очевидно, такие изменения дают $[S1, ] + sort(S$ без $S1)$


### Асимпотика
Пусть $N = |nums|$. Тогда мой алгоритм работает за $O(N * N!)$ - всего $O(N!)$ итераций поиска и копирования следующей перестановки, каждая итерация работает за $O(N)$