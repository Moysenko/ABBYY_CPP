## Задача 1
В случае одиночного наследования:
```c++
struct A {};
struct B: A {};
struct C: B {};
```
Объекты расположены в памяти последовательно:
```A | B | C```

В случае множественного наследования аналогичная ситуация - в памяти сначала лежат данные родительских классов, и уже затем данные класса наследника. Например, в случае ромбовидного наследования:
```c++
struct A {};
struct B : A {};
struct C : A {};
struct D : B, C {};
```
Данные в памяти расположены следующим образом: 
```
[*A | B] | [*A | C] | D
```
где *A ссылаются на одну и ту же область памяти (Уверены? Мы ведь еще не задействовали механизм виртуального наследования)


## Задача 2
Виртуальное наследование - тип наследования, при котором создается лишь один инстанс родительского класса в множественном наследовании. При этом ссылка на него хранится в таблице виртуальных функций

При виртуальном наследовании создается таблица виртуальных функций, через которую будет идти обращение к функциям родительского класса. (Это утверждение относится скорее к виртуальным функциям, а виртуальное наследование немного про другое)

В случае того же ромбовидного наследования данные в памяти будут расположены следующим образом:
```
A | B | C | D
```

## Задача 3
* В случае одиночного наследования, как я уже говорил, данные классов располагаются последовательно. Поэтому поскольку указатель - лишь адрес первого байта объекта, он никак не поменяется при смене типа на какой-то из родительских.
* В случае множественного наследования указатель может поменяться. После смены типа он должен указывать на первый байт самого "старшего" из родительских классов. Соответственно, в случае
    ```c++
    struct A {};
    struct B {};
    struct C : A, B {};

    int main() {
        C* c;
        B* b = c;
        A* a = c;
    }
    ```
    указатели a и с совпадают, а указатель b должен быть чуть больше - его адрес в памяти больше.

## Задача 4
*   ```c++ 
    B b; 
    ``` 
    Сначала вызывается конструктор родительского класса А, затем вызывается конструктор класса B. Тут выведется
    ```
    first
    third
    ```

*   ```C++
    A* p = &b;
    ```
    Тут, ничего не выводится

*   ```c++
    printf("result = (%d ; %d)\n", p->f(), b.f());
    ```
    Первое число - сумма
    * ```i``` = 0
    * ```B::g()``` = 8. Поскольку g - виртуальная, используется версия исходного объекта
    * ```A::h()``` = 6. Здесь h - не виртуальная, функция "перезаписалась" при cохранении в p

    Второе число = 8 - 5, тут ничего интересного
    
    Выведется
    ```
    result = (14 ; 3) 
    ```


*   *Деструктор*
    Сначала вызывается деструктор класса-наследника, и только потом деструктор родителя. Выведется
    ```
    fourth
    second
    ```



Вся программа выведет:
```
first
third
result = (14 ; 3) 
fourth
second
```